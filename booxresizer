#!/usr/bin/env python3
import os
import subprocess
from pathlib import Path
import sys

def get_image_dimensions(image_path):
    """ffprobe를 사용하여 이미지의 너비와 높이를 가져옵니다."""
    try:
        cmd = [
            'ffprobe', '-v', 'error',
            '-select_streams', 'v:0',
            '-show_entries', 'stream=width,height',
            '-of', 'csv=p=0',
            str(image_path)
        ]
        result = subprocess.run(cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True, check=True)
        width, height = map(int, result.stdout.strip().split(','))
        return width, height
    except subprocess.CalledProcessError as e:
        print(f"Error getting dimensions for {image_path}: {e}")
        return None, None

def resize_image(image_path, temp_path):
    """가로 해상도를 824로 리사이즈합니다."""
    ffmpeg_cmd = [
        'ffmpeg', '-i', str(image_path),
        '-vf', 'scale=824:-1',  # 가로를 824로 리사이즈, 세로는 비율 유지
        '-y',  # 기존 파일 덮어쓰지 않음
        str(temp_path)
    ]
    try:
        subprocess.run(ffmpeg_cmd, check=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
        return True
    except subprocess.CalledProcessError as e:
        print(f"Error resizing image {image_path}: {e}")
        return False

def crop_image(temp_path, output_path):
    """세로 해상도를 1648로 중앙 크롭합니다."""
    ffmpeg_cmd = [
        'ffmpeg', '-i', str(temp_path),
        '-vf', 'crop=824:1648',  # 가로는 824 유지, 세로는 1648로 크롭
        '-y',  # 기존 파일 덮어쓰지 않음
        str(output_path)
    ]
    try:
        subprocess.run(ffmpeg_cmd, check=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
        return True
    except subprocess.CalledProcessError as e:
        print(f"Error cropping image {temp_path}: {e}")
        return False

def process_image(image_path):
    img = Path(image_path)
    if not img.is_file():
        print(f"Error: {img} is not a valid file.")
        return

    # 새 파일 이름 생성
    new_image_path = img.stem + "_resized" + img.suffix
    output_path = img.parent / new_image_path

    # 임시 파일 경로 설정
    temp_image_path = img.parent / (img.stem + "_temp" + img.suffix)

    # 이미지 리사이즈
    if not resize_image(img, temp_image_path):
        return

    # 리사이즈된 이미지의 세로 해상도 확인
    _, height = get_image_dimensions(temp_image_path)
    if height is None:
        temp_image_path.unlink(missing_ok=True)
        return

    if height >= 1648:
        # 세로 해상도가 1648 이상이면 크롭
        if crop_image(temp_image_path, output_path):
            print(f"Image resized and cropped, saved as {output_path}")
    else:
        # 세로 해상도가 1648 미만이면 크롭하지 않고 리사이즈된 이미지를 저장
        temp_image_path.rename(output_path)
        print(f"Image resized without cropping, saved as {output_path}")

    # 임시 파일 삭제
    temp_image_path.unlink(missing_ok=True)

def process_images_in_directory(directory):
    supported_formats = ('.jpg', '.jpeg', '.png')
    for img_file in Path(directory).glob('*'):
        if img_file.suffix.lower() in supported_formats:
            process_image(img_file)

def main():
    # 명령줄 인자 처리
    if len(sys.argv) > 1:
        input_path = sys.argv[1]
    else:
        input_path = input("Enter image file or directory path: ").strip()

    if os.path.isfile(input_path):
        process_image(input_path)
    elif os.path.isdir(input_path):
        process_images_in_directory(input_path)
    else:
        print("Invalid input. Please provide a valid file or directory path.")

if __name__ == "__main__":
    main()
